//! NES Color Palette.
//!
//! The NES PPU outputs 6-bit palette indices (0-63) which must be converted
//! to RGB for display. This module provides the standard NTSC palette.

/// RGB color tuple.
pub type Rgb = (u8, u8, u8);

/// Standard NES NTSC palette (64 colors).
///
/// This palette is based on the canonical NTSC NES color output.
/// Each entry is an (R, G, B) tuple.
#[rustfmt::skip]
pub const NES_PALETTE: [Rgb; 64] = [
    // 0x00-0x0F
    (0x62, 0x62, 0x62), // 0x00: Dark gray
    (0x00, 0x2D, 0x69), // 0x01: Dark blue
    (0x00, 0x10, 0x90), // 0x02: Darker blue
    (0x30, 0x08, 0x7B), // 0x03: Dark violet
    (0x59, 0x00, 0x4B), // 0x04: Dark magenta
    (0x69, 0x00, 0x0E), // 0x05: Dark red
    (0x5E, 0x10, 0x00), // 0x06: Dark orange
    (0x40, 0x2D, 0x00), // 0x07: Brown
    (0x16, 0x48, 0x00), // 0x08: Dark olive
    (0x00, 0x59, 0x00), // 0x09: Dark green
    (0x00, 0x5D, 0x00), // 0x0A: Darker green
    (0x00, 0x53, 0x19), // 0x0B: Dark cyan-green
    (0x00, 0x3D, 0x50), // 0x0C: Dark cyan
    (0x00, 0x00, 0x00), // 0x0D: Black
    (0x00, 0x00, 0x00), // 0x0E: Black (mirror)
    (0x00, 0x00, 0x00), // 0x0F: Black (mirror)

    // 0x10-0x1F
    (0xAB, 0xAB, 0xAB), // 0x10: Light gray
    (0x0F, 0x63, 0xB3), // 0x11: Blue
    (0x40, 0x40, 0xDA), // 0x12: Bright blue
    (0x78, 0x28, 0xC5), // 0x13: Violet
    (0xA4, 0x1A, 0x88), // 0x14: Magenta
    (0xB8, 0x17, 0x3B), // 0x15: Red
    (0xAB, 0x30, 0x00), // 0x16: Orange
    (0x84, 0x52, 0x00), // 0x17: Light brown
    (0x4F, 0x74, 0x00), // 0x18: Olive
    (0x14, 0x8B, 0x00), // 0x19: Green
    (0x00, 0x93, 0x00), // 0x1A: Bright green
    (0x00, 0x89, 0x3D), // 0x1B: Cyan-green
    (0x00, 0x6F, 0x81), // 0x1C: Cyan
    (0x00, 0x00, 0x00), // 0x1D: Black
    (0x00, 0x00, 0x00), // 0x1E: Black (mirror)
    (0x00, 0x00, 0x00), // 0x1F: Black (mirror)

    // 0x20-0x2F
    (0xFF, 0xFF, 0xFF), // 0x20: White
    (0x54, 0xAE, 0xFF), // 0x21: Light blue
    (0x88, 0x88, 0xFF), // 0x22: Bright light blue
    (0xC1, 0x6E, 0xFF), // 0x23: Light violet
    (0xEF, 0x5F, 0xDB), // 0x24: Light magenta
    (0xFF, 0x5F, 0x86), // 0x25: Light red
    (0xFF, 0x76, 0x32), // 0x26: Light orange
    (0xD9, 0x9A, 0x00), // 0x27: Yellow
    (0x9E, 0xBD, 0x00), // 0x28: Yellow-green
    (0x5F, 0xD5, 0x00), // 0x29: Light green
    (0x2F, 0xDC, 0x37), // 0x2A: Bright light green
    (0x19, 0xD4, 0x82), // 0x2B: Light cyan-green
    (0x20, 0xBC, 0xC8), // 0x2C: Light cyan
    (0x4C, 0x4C, 0x4C), // 0x2D: Dark gray
    (0x00, 0x00, 0x00), // 0x2E: Black (mirror)
    (0x00, 0x00, 0x00), // 0x2F: Black (mirror)

    // 0x30-0x3F
    (0xFF, 0xFF, 0xFF), // 0x30: White
    (0xB6, 0xDA, 0xFF), // 0x31: Pale blue
    (0xC8, 0xC8, 0xFF), // 0x32: Pale violet-blue
    (0xDE, 0xBC, 0xFF), // 0x33: Pale violet
    (0xF4, 0xB8, 0xF0), // 0x34: Pale magenta
    (0xFF, 0xB8, 0xC7), // 0x35: Pale red
    (0xFF, 0xC1, 0x9E), // 0x36: Pale orange
    (0xF0, 0xD0, 0x78), // 0x37: Pale yellow
    (0xD6, 0xE0, 0x6C), // 0x38: Pale yellow-green
    (0xB8, 0xEC, 0x70), // 0x39: Pale green
    (0xA0, 0xF0, 0x98), // 0x3A: Pale light green
    (0x92, 0xEC, 0xC4), // 0x3B: Pale cyan-green
    (0x98, 0xE0, 0xE8), // 0x3C: Pale cyan
    (0xA8, 0xA8, 0xA8), // 0x3D: Light gray
    (0x00, 0x00, 0x00), // 0x3E: Black (mirror)
    (0x00, 0x00, 0x00), // 0x3F: Black (mirror)
];

/// Get RGB color for a palette index.
#[must_use]
pub fn palette_to_rgb(index: u8) -> Rgb {
    NES_PALETTE[(index & 0x3F) as usize]
}

/// Get RGBA color for a palette index.
#[must_use]
pub fn palette_to_rgba(index: u8) -> (u8, u8, u8, u8) {
    let (r, g, b) = palette_to_rgb(index);
    (r, g, b, 255)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_palette_size() {
        assert_eq!(NES_PALETTE.len(), 64);
    }

    #[test]
    fn test_black_colors() {
        // 0x0D, 0x0E, 0x0F, 0x1D, 0x1E, 0x1F, 0x2E, 0x2F, 0x3E, 0x3F are black
        assert_eq!(NES_PALETTE[0x0D], (0, 0, 0));
        assert_eq!(NES_PALETTE[0x1D], (0, 0, 0));
        assert_eq!(NES_PALETTE[0x2D], (0x4C, 0x4C, 0x4C)); // Dark gray, not black
    }

    #[test]
    fn test_white_colors() {
        // 0x20 and 0x30 are white
        assert_eq!(NES_PALETTE[0x20], (0xFF, 0xFF, 0xFF));
        assert_eq!(NES_PALETTE[0x30], (0xFF, 0xFF, 0xFF));
    }

    #[test]
    fn test_palette_to_rgb() {
        assert_eq!(palette_to_rgb(0x00), (0x62, 0x62, 0x62));
        assert_eq!(palette_to_rgb(0x20), (0xFF, 0xFF, 0xFF));
    }

    #[test]
    fn test_palette_to_rgba() {
        let (r, g, b, a) = palette_to_rgba(0x20);
        assert_eq!((r, g, b, a), (0xFF, 0xFF, 0xFF, 0xFF));
    }

    #[test]
    fn test_palette_index_masking() {
        // Index 0x40 should wrap to 0x00
        assert_eq!(palette_to_rgb(0x40), palette_to_rgb(0x00));
        assert_eq!(palette_to_rgb(0x7F), palette_to_rgb(0x3F));
    }
}
