//! NES palette RGB conversion.
//!
//! Converts NES palette indices (0-63) to RGB colors.

/// NES RGB palette (NTSC, Mesen/Nestopia composite)
///
/// 64 colors, each represented as [R, G, B] in 0-255 range.
/// This is the canonical NTSC palette used by most modern emulators.
const NES_PALETTE: [[u8; 3]; 64] = [
    [0x66, 0x66, 0x66], // 0x00
    [0x00, 0x2A, 0x88], // 0x01
    [0x14, 0x12, 0xA7], // 0x02
    [0x3B, 0x00, 0xA4], // 0x03
    [0x5C, 0x00, 0x7E], // 0x04
    [0x6E, 0x00, 0x40], // 0x05
    [0x6C, 0x06, 0x00], // 0x06
    [0x56, 0x1D, 0x00], // 0x07
    [0x33, 0x35, 0x00], // 0x08
    [0x0B, 0x48, 0x00], // 0x09
    [0x00, 0x52, 0x00], // 0x0A
    [0x00, 0x4F, 0x08], // 0x0B
    [0x00, 0x40, 0x4D], // 0x0C
    [0x00, 0x00, 0x00], // 0x0D
    [0x00, 0x00, 0x00], // 0x0E
    [0x00, 0x00, 0x00], // 0x0F
    [0xAD, 0xAD, 0xAD], // 0x10
    [0x15, 0x5F, 0xD9], // 0x11
    [0x42, 0x40, 0xFF], // 0x12
    [0x75, 0x27, 0xFE], // 0x13
    [0xA0, 0x1A, 0xCC], // 0x14
    [0xB7, 0x1E, 0x7B], // 0x15
    [0xB5, 0x31, 0x20], // 0x16
    [0x99, 0x4E, 0x00], // 0x17
    [0x6B, 0x6D, 0x00], // 0x18
    [0x38, 0x87, 0x00], // 0x19
    [0x0C, 0x93, 0x00], // 0x1A
    [0x00, 0x8F, 0x32], // 0x1B
    [0x00, 0x7C, 0x8D], // 0x1C
    [0x00, 0x00, 0x00], // 0x1D
    [0x00, 0x00, 0x00], // 0x1E
    [0x00, 0x00, 0x00], // 0x1F
    [0xFF, 0xFE, 0xFF], // 0x20
    [0x64, 0xB0, 0xFF], // 0x21
    [0x92, 0x90, 0xFF], // 0x22
    [0xC6, 0x76, 0xFF], // 0x23
    [0xF3, 0x6A, 0xFF], // 0x24
    [0xFE, 0x6E, 0xCC], // 0x25
    [0xFE, 0x81, 0x70], // 0x26
    [0xEA, 0x9E, 0x22], // 0x27
    [0xBC, 0xBE, 0x00], // 0x28
    [0x88, 0xD8, 0x00], // 0x29
    [0x5C, 0xE4, 0x30], // 0x2A
    [0x45, 0xE0, 0x82], // 0x2B
    [0x48, 0xCD, 0xDE], // 0x2C
    [0x4F, 0x4F, 0x4F], // 0x2D
    [0x00, 0x00, 0x00], // 0x2E
    [0x00, 0x00, 0x00], // 0x2F
    [0xFF, 0xFE, 0xFF], // 0x30
    [0xC0, 0xDF, 0xFF], // 0x31
    [0xD3, 0xD2, 0xFF], // 0x32
    [0xE8, 0xC8, 0xFF], // 0x33
    [0xFB, 0xC2, 0xFF], // 0x34
    [0xFE, 0xC4, 0xEA], // 0x35
    [0xFE, 0xCC, 0xC5], // 0x36
    [0xF7, 0xD8, 0xA5], // 0x37
    [0xE4, 0xE5, 0x94], // 0x38
    [0xCF, 0xEF, 0x96], // 0x39
    [0xBD, 0xF4, 0xAB], // 0x3A
    [0xB3, 0xF3, 0xCC], // 0x3B
    [0xB5, 0xEB, 0xF2], // 0x3C
    [0xB8, 0xB8, 0xB8], // 0x3D
    [0x00, 0x00, 0x00], // 0x3E
    [0x00, 0x00, 0x00], // 0x3F
];

/// Convert NES palette index to RGB color
///
/// # Arguments
///
/// * `index` - Palette index (0-63)
///
/// # Returns
///
/// RGB color as [R, G, B]
#[must_use]
pub fn palette_to_rgb(index: u8) -> [u8; 3] {
    NES_PALETTE[usize::from(index & 0x3F)]
}

/// Convert NES framebuffer (palette indices) to RGB buffer
///
/// # Arguments
///
/// * `framebuffer` - Palette indices (256×240 = 61,440 bytes)
///
/// # Returns
///
/// RGB buffer (256×240×3 = 184,320 bytes)
#[must_use]
pub fn framebuffer_to_rgb(framebuffer: &[u8]) -> Vec<u8> {
    let mut rgb = Vec::with_capacity(256 * 240 * 3);

    for &index in framebuffer {
        let color = palette_to_rgb(index);
        rgb.push(color[0]); // R
        rgb.push(color[1]); // G
        rgb.push(color[2]); // B
    }

    rgb
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_palette_to_rgb() {
        // Test first color (gray)
        assert_eq!(palette_to_rgb(0x00), [0x66, 0x66, 0x66]);

        // Test white
        assert_eq!(palette_to_rgb(0x20), [0xFF, 0xFE, 0xFF]);

        // Test palette wrapping (indices > 63 wrap)
        assert_eq!(palette_to_rgb(0x40), palette_to_rgb(0x00));
        assert_eq!(palette_to_rgb(0xFF), palette_to_rgb(0x3F));
    }

    #[test]
    fn test_framebuffer_to_rgb() {
        // Test small framebuffer
        let framebuffer = vec![0x00, 0x20, 0x0D];
        let rgb = framebuffer_to_rgb(&framebuffer);

        assert_eq!(rgb.len(), 9); // 3 pixels × 3 bytes
        assert_eq!(&rgb[0..3], &[0x66, 0x66, 0x66]); // First pixel
        assert_eq!(&rgb[3..6], &[0xFF, 0xFE, 0xFF]); // Second pixel
        assert_eq!(&rgb[6..9], &[0x00, 0x00, 0x00]); // Third pixel
    }
}
